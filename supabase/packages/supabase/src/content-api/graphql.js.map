{"version":3,"file":"graphql.js","sourceRoot":"","sources":["graphql.ts"],"names":[],"mappings":"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","sourcesContent":["import {\r\n  buildSchema,\r\n  GraphQLError,\r\n  GraphQLSchema,\r\n  parse,\r\n  validate,\r\n  type DocumentNode,\r\n} from 'graphql';\r\nimport { z } from 'zod';\r\n\r\nexport const graphqlRequestSchema = z.object({\r\n  query: z.string(),\r\n  variables: z.record(z.string(), z.unknown()).optional(),\r\n});\r\n\r\nexport const graphqlResponseSuccessSchema = z.object({\r\n  data: z.record(z.string(), z.unknown()),\r\n  errors: z.undefined(),\r\n});\r\n\r\nexport const graphqlErrorSchema = z.object({\r\n  message: z.string(),\r\n  locations: z.array(\r\n    z.object({\r\n      line: z.number(),\r\n      column: z.number(),\r\n    })\r\n  ),\r\n});\r\n\r\nexport const graphqlResponseErrorSchema = z.object({\r\n  data: z.undefined(),\r\n  errors: z.array(graphqlErrorSchema),\r\n});\r\n\r\nexport const graphqlResponseSchema = z.union([\r\n  graphqlResponseSuccessSchema,\r\n  graphqlResponseErrorSchema,\r\n]);\r\n\r\nexport type GraphQLRequest = z.infer<typeof graphqlRequestSchema>;\r\nexport type GraphQLResponse = z.infer<typeof graphqlResponseSchema>;\r\n\r\nexport type QueryFn = (\r\n  request: GraphQLRequest\r\n) => Promise<Record<string, unknown>>;\r\n\r\nexport type QueryOptions = {\r\n  validateSchema?: boolean;\r\n};\r\n\r\nexport type GraphQLClientOptions = {\r\n  /**\r\n   * The URL of the GraphQL endpoint.\r\n   */\r\n  url: string;\r\n\r\n  /**\r\n   * A function that loads the GraphQL schema.\r\n   * This will be used for validating future queries.\r\n   *\r\n   * A `query` function is provided that can be used to\r\n   * execute GraphQL queries against the endpoint\r\n   * (e.g. if the API itself allows querying the schema).\r\n   */\r\n  loadSchema?({ query }: { query: QueryFn }): Promise<string>;\r\n\r\n  /**\r\n   * Optional headers to include in the request.\r\n   */\r\n  headers?: Record<string, string>;\r\n};\r\n\r\nexport class GraphQLClient {\r\n  #url: string;\r\n  #headers: Record<string, string>;\r\n\r\n  /**\r\n   * A promise that resolves when the schema is loaded via\r\n   * the `loadSchema` function.\r\n   *\r\n   * Resolves to an object containing the raw schema source\r\n   * string and the parsed GraphQL schema.\r\n   *\r\n   * Rejects if no `loadSchema` function was provided to\r\n   * the constructor.\r\n   */\r\n  schemaLoaded: Promise<{\r\n    /**\r\n     * The raw GraphQL schema string.\r\n     */\r\n    source: string;\r\n\r\n    /**\r\n     * The parsed GraphQL schema.\r\n     */\r\n    schema: GraphQLSchema;\r\n  }>;\r\n\r\n  /**\r\n   * Creates a new GraphQL client.\r\n   */\r\n  constructor(options: GraphQLClientOptions) {\r\n    this.#url = options.url;\r\n    this.#headers = options.headers ?? {};\r\n\r\n    this.schemaLoaded =\r\n      options\r\n        .loadSchema?.({ query: this.#query.bind(this) })\r\n        .then((source) => ({\r\n          source,\r\n          schema: buildSchema(source),\r\n        })) ?? Promise.reject(new Error('No schema loader provided'));\r\n\r\n    // Prevent unhandled promise rejections\r\n    this.schemaLoaded.catch(() => {});\r\n  }\r\n\r\n  /**\r\n   * Executes a GraphQL query against the provided URL.\r\n   */\r\n  async query(\r\n    request: GraphQLRequest,\r\n    options: QueryOptions = { validateSchema: true }\r\n  ) {\r\n    try {\r\n      // Check that this is a valid GraphQL query\r\n      const documentNode = parse(request.query);\r\n\r\n      // Validate the query against the schema if requested\r\n      if (options.validateSchema) {\r\n        const { schema } = await this.schemaLoaded;\r\n        const errors = validate(schema, documentNode);\r\n        if (errors.length > 0) {\r\n          throw new Error(\r\n            `Invalid GraphQL query: ${errors.map((e) => e.message).join(', ')}`\r\n          );\r\n        }\r\n      }\r\n\r\n      return this.#query(request);\r\n    } catch (error) {\r\n      // Make it obvious that this is a GraphQL error\r\n      if (error instanceof GraphQLError) {\r\n        throw new Error(`Invalid GraphQL query: ${error.message}`);\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Executes a GraphQL query against the provided URL.\r\n   *\r\n   * Does not validate the query against the schema.\r\n   */\r\n  async #query(request: GraphQLRequest) {\r\n    const { query, variables } = request;\r\n\r\n    const response = await fetch(this.#url, {\r\n      method: 'POST',\r\n      headers: {\r\n        ...this.#headers,\r\n        'Content-Type': 'application/json',\r\n        Accept: 'application/json',\r\n      },\r\n      body: JSON.stringify({\r\n        query,\r\n        variables,\r\n      }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error(\r\n        `Failed to fetch Supabase Content API GraphQL schema: HTTP status ${response.status}`\r\n      );\r\n    }\r\n\r\n    const json = await response.json();\r\n\r\n    const { data, error } = graphqlResponseSchema.safeParse(json);\r\n\r\n    if (error) {\r\n      throw new Error(\r\n        `Failed to parse Supabase Content API response: ${error.message}`\r\n      );\r\n    }\r\n\r\n    if (data.errors) {\r\n      throw new Error(\r\n        `Supabase Content API GraphQL error: ${data.errors\r\n          .map(\r\n            (err) =>\r\n              `${err.message} (line ${err.locations[0]?.line ?? 'unknown'}, column ${err.locations[0]?.column ?? 'unknown'})`\r\n          )\r\n          .join(', ')}`\r\n      );\r\n    }\r\n\r\n    return data.data;\r\n  }\r\n}\r\n\r\n/**\r\n * Extracts the fields from a GraphQL query document.\r\n */\r\nexport function getQueryFields(document: DocumentNode) {\r\n  return document.definitions\r\n    .filter((def) => def.kind === 'OperationDefinition')\r\n    .flatMap((def) => {\r\n      if (def.kind === 'OperationDefinition' && def.selectionSet) {\r\n        return def.selectionSet.selections\r\n          .filter((sel) => sel.kind === 'Field')\r\n          .map((sel) => {\r\n            if (sel.kind === 'Field') {\r\n              return sel.name.value;\r\n            }\r\n            return null;\r\n          })\r\n          .filter(Boolean);\r\n      }\r\n      return [];\r\n    });\r\n}\r\n"]}