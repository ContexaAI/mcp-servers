{"version":3,"file":"util.js","sourceRoot":"","sources":["util.ts"],"names":[],"mappings":"AAgCA,MAAM,UAAU,iBAAiB,CAAC,IAAY;IAC5C,OAAO,MAAM,CAAC,WAAW,CACvB,IAAI;SACD,KAAK,CAAC,IAAI,CAAC;SACX,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;SAClC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC;SACtB,GAAG,CAAC,CAAC,CAAC,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE,CAAC,CAAC,GAAG,EAAE,KAAK,IAAI,EAAE,CAAC,CAAC,CAC7C,CAAC;AACJ,CAAC;AAOD,MAAM,CAAC,KAAK,UAAU,UAAU,CAC9B,GAAwB,EACxB,MAAe;IAGf,MAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE;QAC3C,IAAI,KAAK,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;YAChE,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC;iBACtB,IAAI,EAAE;iBACN,MAAM,CAAsB,CAAC,MAAM,EAAE,GAAG,EAAE,EAAE;gBAC3C,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;gBACzB,OAAO,MAAM,CAAC;YAChB,CAAC,EAAE,EAAE,CAAC,CAAC;QACX,CAAC;QACD,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;IAEH,MAAM,MAAM,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,MAAM,CACvC,SAAS,EACT,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,CAC9B,CAAC;IAGF,MAAM,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,GAAG,IAAI,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IACxE,OAAO,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;AACrC,CAAC","sourcesContent":["export type ValueOf<T> = T[keyof T];\r\n\r\n// UnionToIntersection<A | B> = A & B\r\nexport type UnionToIntersection<U> = (\r\n  U extends unknown\r\n    ? (arg: U) => 0\r\n    : never\r\n) extends (arg: infer I) => 0\r\n  ? I\r\n  : never;\r\n\r\n// LastInUnion<A | B> = B\r\nexport type LastInUnion<U> = UnionToIntersection<\r\n  U extends unknown ? (x: U) => 0 : never\r\n> extends (x: infer L) => 0\r\n  ? L\r\n  : never;\r\n\r\n// UnionToTuple<A, B> = [A, B]\r\nexport type UnionToTuple<T, Last = LastInUnion<T>> = [T] extends [never]\r\n  ? []\r\n  : [Last, ...UnionToTuple<Exclude<T, Last>>];\r\n\r\n/**\r\n * Parses a key-value string into an object.\r\n *\r\n * @returns An object representing the key-value pairs\r\n *\r\n * @example\r\n * const result = parseKeyValueList(\"key1=value1\\nkey2=value2\");\r\n * console.log(result); // { key1: \"value1\", key2: \"value2\" }\r\n */\r\nexport function parseKeyValueList(data: string): { [key: string]: string } {\r\n  return Object.fromEntries(\r\n    data\r\n      .split('\\n')\r\n      .map((item) => item.split(/=(.*)/)) // split only on the first '='\r\n      .filter(([key]) => key) // filter out empty keys\r\n      .map(([key, value]) => [key, value ?? '']) // ensure value is not undefined\r\n  );\r\n}\r\n\r\n/**\r\n * Creates a unique hash from a JavaScript object.\r\n * @param obj - The object to hash\r\n * @param length - Optional length to truncate the hash (default: full length)\r\n */\r\nexport async function hashObject(\r\n  obj: Record<string, any>,\r\n  length?: number\r\n): Promise<string> {\r\n  // Sort object keys to ensure consistent output regardless of original key order\r\n  const str = JSON.stringify(obj, (_, value) => {\r\n    if (value && typeof value === 'object' && !Array.isArray(value)) {\r\n      return Object.keys(value)\r\n        .sort()\r\n        .reduce<Record<string, any>>((result, key) => {\r\n          result[key] = value[key];\r\n          return result;\r\n        }, {});\r\n    }\r\n    return value;\r\n  });\r\n\r\n  const buffer = await crypto.subtle.digest(\r\n    'SHA-256',\r\n    new TextEncoder().encode(str)\r\n  );\r\n\r\n  // Convert to base64\r\n  const base64Hash = btoa(String.fromCharCode(...new Uint8Array(buffer)));\r\n  return base64Hash.slice(0, length);\r\n}\r\n"]}